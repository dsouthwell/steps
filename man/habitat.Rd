% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/habitat-class.R
\name{patches}
\alias{[[.habitat}
\alias{area}
\alias{as.distance}
\alias{as.habitat}
\alias{as.population}
\alias{distance}
\alias{features}
\alias{is.distance}
\alias{is.habitat}
\alias{is.patches}
\alias{is.population}
\alias{patches}
\alias{pop_patch_name}
\alias{population}
\alias{print.habitat}
\title{habitat objects}
\usage{
patches(x, distance, p4s, givedist = TRUE)

is.patches(x)

as.habitat(patches)

is.habitat(x)

\method{print}{habitat}(x, ...)

as.distance(x, ...)

is.distance(x)

as.population(x, ...)

is.population(x)

pop_patch_name(population)

area(habitat)

population(habitat)

features(habitat)

distance(habitat)

\method{[[}{habitat}(x, i)
}
\arguments{
\item{x}{a binary Raster layer (0 or NA for background, and 1 for areas to be clumped)}

\item{distance}{the neighbourhood distance. Patches that occur within this distance of
one another will be clumped. This should be in the units of the CRS given
in p4s. If this is zero, the function will identify patches defined by 
8-connectivity (i.e. queen's case).}

\item{p4s}{an equal-area projection appropriate for the region. This will be used when 
calculating inter-patch distances. The returned objects will be in the 
original coordinate system.}

\item{givedist}{should the distance matrix be returned? (logical). Distances are in the 
units of p4s, and are shortest cartesian distances between patches.}

\item{patches}{an object to turn into a \code{habitat} object. Currently
this can either be a dynamic, a list or \code{NULL} (see \code{details}),
though more approaches will be added in the future}

\item{population}{matrix of states as cols and patches as rows.}

\item{habitat}{an object of class \code{habitat}}

\item{i}{index specifying the patches to include in the subset
\code{habitat} object}

\item{x}{an object to print or test as a habitat object}

\item{\dots}{further arguments passed to or from other methods.}

\item{x}{a vector, data.frame or matrix of distance(s) numbers for each stage(s) and each patch(s)}

\item{x}{a vector, data.frame or matrix of population(s) numbers for each stage(s) and each patch(s)}
}
\value{
an object of class \code{habitat}, essentially a dataframe
  containing the coordinates, area, population and features (as columns) for
  each patch (rows)
}
\description{
Underlying habitat for dlmpr.
}
\details{
the accessor functions \code{distance}, \code{area},
  \code{population} and \code{features} either return or set corresponding
  sub-dataframes of the \code{habitat} object
}
\examples{
library(raster)
set.seed(42)
xy <- expand.grid(x=seq(145, 150, 0.1), y=seq(-40, -35, 0.1))
Dd <- as.matrix(dist(xy))
w <- exp(-1/nrow(xy) * Dd)
Ww <- chol(w)
xy$z <- t(Ww) \%*\% rnorm(nrow(xy), 0, 0.1)
coordinates(xy) <- ~x+y
r <- rasterize(xy, raster(points2grid(xy)), 'z')
r2 <- raster(r)
res(r2) <- 0.01
r2 <- resample(r, r2)
proj4string(r2) <- '+init=epsg:4283'
rthr <- r2 > quantile(r2, 0.9)
foo <- patches(rthr, distance=1000, '+init=epsg:3577')
plot(foo$patchrast)
text(foo$coords[, 2:3], labels = foo$coords[, 1])
# create a default habitat
habitat <- as.habitat(NULL)

# create a marginally more interesting one-patch habitat
habitat <- as.habitat(list(coordinates = data.frame(x=runif( 10, min=-10, max=10),
                                                    y=runif( 10, min=-10, max=10)),
                               area = as.data.frame(exp(-seq(.1,10,length.out = 10))*10),
                               population = as.population(t(rmultinom(10, 
                               size = 100, prob = c(0.8,0.2,0.01)))),
                               features = data.frame(temperature = 10)))
# print method
print(habitat)

# starting distance numbers for each step in the demographic function
distance <- as.distance(c(80,30,10))
distance <- as.distance(t(rmultinom(10, size = 100, prob = c(0.8,0.2,0.01))))
distance <- as.distance(c(80,30,10))
is.distance(distance)
# starting population numbers for each step in the demographic function
population <- as.population(c(80,30,10))
population <- as.population(t(rmultinom(10, size = 100, prob = c(0.8,0.2,0.01))))
population <- as.population(c(80,30,10))
is.population(population)
# get and set the area
area(habitat)

# get and set the population
population(habitat)
# get and set the features
features(habitat)

# get and set the distance matrix
distance(habitat)

# habitats can be subsetted to get sub-habitats of patches with double
# braces
habitat
habitat[[1]]
habitat[[1:2]]

}
\author{
John Baumgartner
}

