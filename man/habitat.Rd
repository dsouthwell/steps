% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/habitat-class.R
\name{patchify}
\alias{K}
\alias{[[.habitat}
\alias{area}
\alias{area<-}
\alias{as.habitat}
\alias{as.population}
\alias{coords}
\alias{coords<-}
\alias{distance}
\alias{features}
\alias{features<-}
\alias{is.distance}
\alias{is.habitat}
\alias{is.patches}
\alias{is.population}
\alias{patchify}
\alias{pop_patch_name}
\alias{population}
\alias{population<-}
\alias{print.habitat}
\alias{spatial_patches}
\alias{spatial_patches<-}
\alias{suitability}
\alias{suitability<-}
\title{habitat objects}
\usage{
patchify(x, distance, p4s, givedist = TRUE)

is.patches(x)

as.habitat(patches)

is.habitat(x)

\method{print}{habitat}(x, ...)

area(habitat)

area(habitat) <- value

as.population(x, ...)

is.population(x)

population(habitat)

population(habitat) <- value

pop_patch_name(habitat)

features(habitat)

features(habitat) <- value

spatial_patches(habitat)

spatial_patches(habitat, newpatch) <- value

suitability(habitat)

suitability(habitat, newpatch) <- value

coords(habitat)

coords(habitat) <- value

distance(habitat)

is.distance(x)

\method{[[}{habitat}(x, i)

K(x, a = 1, b = 0.2, c = 0.5, type = c("exp", "logit", "linear"))
}
\arguments{
\item{x}{a binary Raster layer (0 or NA for background, and 1 for areas to be clumped)}

\item{distance}{the neighbourhood distance. patchify that occur within this distance of
one another will be clumped. This should be in the units of the CRS given
in p4s. If this is zero, the function will identify patches defined by 
8-connectivity (i.e. queen's case).}

\item{p4s}{an equal-area projection appropriate for the region. This will be used when 
calculating inter-patch distances. The returned objects will be in the 
original coordinate system.}

\item{givedist}{should the distance matrix be returned? (logical). Distances are in the 
units of p4s, and are shortest cartesian distances between patches.}

\item{patches}{an object to turn into a \code{habitat} object. Currently
this can either be a \link[raster]{raster}, a list or \code{NULL} (see \code{details}),
though more approaches will be added in the future}

\item{habitat}{an object of class \code{habitat}}

\item{i}{index specifying the patches to include in the subset
\code{habitat} object}

\item{a}{parameter for carrying capacity model}

\item{b}{parameter for carrying capacity model}

\item{c}{parameter for carrying capacity model}

\item{type}{model form for converting occurrence to carrying capacity.}

\item{x}{an object to print or test as a habitat object}

\item{\dots}{further arguments passed to or from other methods.}

\item{x}{a vector, data.frame or matrix of population(s) numbers for each stage(s) and each patch(s)}

\item{x}{a raster of species habitit suitability (occupancy)}
}
\value{
an object of class \code{habitat}, essentially a dataframe
  containing the coordinates, area, population and features (as columns) for
  each patch (rows)
}
\description{
Underlying habitat for dlmpr.
}
\details{
the accessor functions \code{distance}, \code{area},
  \code{population} and \code{features} either return or set corresponding
  sub-dataframes of the \code{habitat} object
}
\examples{
library(raster)
set.seed(42)
xy <- expand.grid(x=seq(145, 150, 0.1), y=seq(-40, -35, 0.1))
Dd <- as.matrix(dist(xy))
w <- exp(-1/nrow(xy) * Dd)
Ww <- chol(w)
xy$z <- t(Ww) \%*\% rnorm(nrow(xy), 0, 0.1)
coordinates(xy) <- ~x+y
r <- rasterize(xy, raster(points2grid(xy)), 'z')
r2 <- raster(r)
res(r2) <- 0.01
r2 <- resample(r, r2)
proj4string(r2) <- '+init=epsg:4283'
foo <- patchify(r2,distance=1000,p4s='+init=epsg:4283')

#'# create a habitat from a list containing a raster that represents a habitat suitability model / species distribution model.
habitat <- as.habitat(list(r2,population = as.population(t(rmultinom(1, 
                               size = 100, prob = c(0.8,0.2,0.01))))))
                               
#create a habitat from a list containing just a species distribution model will estimate populations per-patch.
habitat <- as.habitat(list(r2))

# create a default habitat
habitat <- as.habitat(NULL)

# create a multipatch habitat
patches <- list(coordinates = data.frame(x=runif( 10, min=-10, max=10),
                                                    y=runif( 10, min=-10, max=10)),
                               area = as.data.frame(exp(-seq(.1,10,length.out = 10))*10),
                               population = as.population(t(rmultinom(1, 
                               size = 100, prob = c(0.8,0.2,0.01)))),
                               features = data.frame(temperature = 10))
habitat <- as.habitat(patches)
                               
# print method
print(habitat)

# get and set the area
area(habitat)

# starting population numbers for each step in the demographic function
population <- as.population(c(80,30,10))
population <- as.population(t(rmultinom(10, size = 100, prob = c(0.8,0.2,0.01))))
population <- as.population(c(80,30,10))
is.population(population)
# get and set the population
population(habitat)
population(habitat) <- population(habitat) * 2
population(habitat)

# get and set the features
features(habitat)
# get and set the features
spatial_patches(habitat)

# get and set the features
suitability(habitat)

# get and set the features
coordinates(habitat)

# get and set the distance matrix
distance(habitat)

# habitats can be subsetted to get sub-habitats of patches with double
# braces
habitat
habitat[[1]]
habitat[[1:2]]

}
\author{
John Baumgartner

Nick Golding

Skipton Woolley
}

